import{_ as a,o as e,c as i,e as n}from"./app-8007fa1b.js";const s="/assets/img010-25a5197e.png",l="/assets/img011-f9eb146c.png",r="/assets/img012-a42e7730.png",d="/assets/img013-99584e8e.png",t="/assets/img014-51c7f0e3.png",c="/assets/img015-8f54a3d2.png",p={},o=n(`<h1 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念" aria-hidden="true">#</a> 一、概念</h1><h2 id="_1、不使用索引的一般的查询" tabindex="-1"><a class="header-anchor" href="#_1、不使用索引的一般的查询" aria-hidden="true">#</a> 1、不使用索引的一般的查询</h2><ul><li>设定查询条件</li><li>逐一检查每一条记录，看看是否满足查询条件</li></ul><br><p>例如：</p><ul><li>查字典：在正文中一页一页查找某一个字</li><li>到图书馆找某一本书：逐个楼层、逐个房间、逐个书架、一本书一本书去找……</li><li>到医院找某一个科室：逐个楼层、逐个房间、一个一个找……</li></ul><br><h2 id="_2、使用索引查询" tabindex="-1"><a class="header-anchor" href="#_2、使用索引查询" aria-hidden="true">#</a> 2、使用索引查询</h2><p>检索：通常就是只基于索引查询<br></p><ul><li>查字典：先在检字表里找到这个字在第几页，然后直接翻到这一页，检字表就是字典的索引</li><li>到图书馆找某一本书：先在外面通过电脑或卡片找到你所需书在具体哪个位置，然后直奔这个位置找到这本书</li><li>到医院找某一个科室：先在楼下看看楼层科室牌子</li></ul><p>所以索引是在数据之外，额外建立的一组数据，专门帮助我们提高查询的效率<br></p><h2 id="_3、索引的评价" tabindex="-1"><a class="header-anchor" href="#_3、索引的评价" aria-hidden="true">#</a> 3、索引的评价</h2><ul><li>使用索引的好处：在特定场景下大幅度提高查询的效率</li><li>使用索引的弊端： <ul><li>索引本身也需要占用存储的空间</li><li>一旦执行了增删改操作，索引就需要跟着修改，所以会增删改操作的效率</li></ul></li></ul><br><h1 id="二、操作索引" tabindex="-1"><a class="header-anchor" href="#二、操作索引" aria-hidden="true">#</a> 二、操作索引</h1><h2 id="_1、创建索引" tabindex="-1"><a class="header-anchor" href="#_1、创建索引" aria-hidden="true">#</a> 1、创建索引</h2><p>创建数据库表之后，只要指定了主键字段，那么主键索引就自动创建了，不需要额外手动创建<br> 所以我们手动创建的索引，都是在非主键字段上创建的，这样的索引可以称之为：</p><ul><li>非主键索引</li><li>二级索引</li><li>非聚簇索引</li></ul><br><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 针对一个字段，创建一个普通的索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_emp_name <span class="token keyword">on</span> t_emp<span class="token punctuation">(</span>emp_name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 针对一个字段，创建一个唯一索引</span>
<span class="token comment"># 唯一索引会要求这个字段的值不能重复</span>
<span class="token comment"># 底层 MySQL 会在创建唯一索引的时候，自动添加唯一约束</span>
<span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> idx_emp_salary <span class="token keyword">on</span> t_emp<span class="token punctuation">(</span>emp_salary<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 针对多个字段，创建一个普通索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_emp_name_salary <span class="token keyword">on</span> t_emp<span class="token punctuation">(</span>emp_name<span class="token punctuation">,</span> emp_salary<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 针对多个字段，创建一个唯一索引</span>
<span class="token comment"># 当我们针对多个字段设定唯一约束时，只要保证这多个字段的值组合起来不重复即可</span>
<span class="token comment"># 延伸：主键也不是只能包含一个字段，主键包含多个字段时称为联合主键</span>
<span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> idx_emp_name_subject <span class="token keyword">on</span> t_emp<span class="token punctuation">(</span>emp_name<span class="token punctuation">,</span> emp_subject<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><h2 id="_2、删除索引" tabindex="-1"><a class="header-anchor" href="#_2、删除索引" aria-hidden="true">#</a> 2、删除索引</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 删除索引</span>
<span class="token keyword">drop</span> <span class="token keyword">index</span> idx_emp_name <span class="token keyword">on</span> t_emp<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="三、索引的分类" tabindex="-1"><a class="header-anchor" href="#三、索引的分类" aria-hidden="true">#</a> 三、索引的分类</h1><ul><li>从索引包含的字段数量角度 <ul><li>单列索引（单值索引）</li><li>多列索引（多值索引）</li></ul></li><li>从索引字段是否是主键角度 <ul><li>主键索引（值不能重复，且不能为空）</li><li>非主键索引（二级索引）</li></ul></li><li>从是否有唯一性要求角度 <ul><li>唯一索引（值不能重复，但null值可以有多个）</li><li>非唯一索引</li></ul></li><li>从索引和原始数据是否在一起角度 <ul><li>聚簇索引</li><li>非聚簇索引</li></ul></li><li>从索引实现的特定功能角度 <ul><li>空间索引：用于做基于地理位置（经纬度）的数据的保存</li><li>全文索引：先对原始字符串做分词操作，然后使用搜索关键词和分词结果进行匹配</li></ul></li></ul><br><h1 id="四、推演索引的构成" tabindex="-1"><a class="header-anchor" href="#四、推演索引的构成" aria-hidden="true">#</a> 四、推演索引的构成</h1><h2 id="_1、基础概念" tabindex="-1"><a class="header-anchor" href="#_1、基础概念" aria-hidden="true">#</a> 1、基础概念</h2><p>InnoDB 存储数据的最小单位：页<br> 页默认大小：16KB<br> 假设一条记录大小：1KB<br> 由此推断：一页可以保存记录的数量16KB÷1KB=16</p><br><h2 id="_2、页码" tabindex="-1"><a class="header-anchor" href="#_2、页码" aria-hidden="true">#</a> 2、页码</h2><p><img src="`+s+'" alt="img.png"></p><br><h2 id="_3、抽取第一层目录" tabindex="-1"><a class="header-anchor" href="#_3、抽取第一层目录" aria-hidden="true">#</a> 3、抽取第一层目录</h2><h3 id="_1目录记录的来历" tabindex="-1"><a class="header-anchor" href="#_1目录记录的来历" aria-hidden="true">#</a> ①目录记录的来历</h3><p><img src="'+l+'" alt="img.png"></p><br><h3 id="_2推算一条目录记录占空间大小" tabindex="-1"><a class="header-anchor" href="#_2推算一条目录记录占空间大小" aria-hidden="true">#</a> ②推算一条目录记录占空间大小</h3><p>假设主键字段和页码都是整数，都使用big int类型（相当于Java中的long类型），所以一条目录记录，我们就按8×2=16B计算</p><br><h3 id="_3页存储目录记录容量" tabindex="-1"><a class="header-anchor" href="#_3页存储目录记录容量" aria-hidden="true">#</a> ③页存储目录记录容量</h3><p>InnoDB引擎中，存储目录记录页是使用页作为最小的存储单元：</p><ul><li>页默认大小：16KB</li><li>一条目录记录：16B</li><li>目录记录容量：1024</li></ul><br><h3 id="_4目录页的来历" tabindex="-1"><a class="header-anchor" href="#_4目录页的来历" aria-hidden="true">#</a> ④目录页的来历</h3><p><img src="'+r+'" alt="img.png"></p><br><h2 id="_4、基于目录的查找" tabindex="-1"><a class="header-anchor" href="#_4、基于目录的查找" aria-hidden="true">#</a> 4、基于目录的查找</h2><p><img src="'+d+'" alt="img.png"></p><br><h2 id="_5、抽取第二层目录" tabindex="-1"><a class="header-anchor" href="#_5、抽取第二层目录" aria-hidden="true">#</a> 5、抽取第二层目录</h2><p><img src="'+t+'" alt="img.png"></p><br><p>通过两次抽取，我们能够体会到，按照目前这个抽取方式，不断向上汇总，最终一定能够汇总到一个节点中——在最顶端，一个目录页就够了<br></p><p>此时我们把每一个页都看做一个节点，那么它们整体就形成了一个树形结构：<span style="color:blue;font-weight:bold;">B+Tree</span><br></p><h2 id="_6、基于两层目录的搜索方式" tabindex="-1"><a class="header-anchor" href="#_6、基于两层目录的搜索方式" aria-hidden="true">#</a> 6、基于两层目录的搜索方式</h2><p><img src="'+c+'" alt="img.png"></p><br><h1 id="五、btree和b-tree的区别" tabindex="-1"><a class="header-anchor" href="#五、btree和b-tree的区别" aria-hidden="true">#</a> 五、BTree和B+Tree的区别</h1><h2 id="_1、btree特点" tabindex="-1"><a class="header-anchor" href="#_1、btree特点" aria-hidden="true">#</a> 1、BTree特点</h2><ul><li>不区分目录节点、数据节点，所有节点都是既保存子节点的指针，又保存原始数据记录</li><li>所以每个节点保存的记录数量就会减少</li><li>横向来看：变窄</li><li>纵向来看：变高</li><li>BTree的整体形态：高瘦、尖锐 <ul><li>层次深度多</li><li>每一层能够保存的数据少</li></ul></li></ul><br><h2 id="_2、b-tree特点" tabindex="-1"><a class="header-anchor" href="#_2、b-tree特点" aria-hidden="true">#</a> 2、B+Tree特点</h2><ul><li>仅在叶子节点保存原始记录数据</li><li>非叶子节点都是目录节点</li><li>目录节点只保存目录，所以每个节点能够保存的记录数量就大</li><li>横向来看：变宽</li><li>纵向来看：变矮</li><li>B+Tree的整体形态：矮胖、扁平 <ul><li>层次深度少</li><li>每一层能够保存的数据多</li></ul></li></ul><br><h2 id="_3、树形结构对查询效率的影响" tabindex="-1"><a class="header-anchor" href="#_3、树形结构对查询效率的影响" aria-hidden="true">#</a> 3、树形结构对查询效率的影响</h2><ul><li>MySQL 默认把树形结构的根节点加载到内存</li><li>需要使用子节点时到硬盘加载</li><li>每需要一层就到硬盘加载一层</li><li>所以树形结构层次深度多的时候，访问硬盘的I/O次数就会多，性能就会差</li></ul><h2 id="_4、推算b-tree容量" tabindex="-1"><a class="header-anchor" href="#_4、推算b-tree容量" aria-hidden="true">#</a> 4、推算B+Tree容量</h2><ul><li>一个数据页容量：16</li><li>一个目录页容量：1024</li><li>整个B+Tree如果只有一层：意味着只能有一个根节点，这个节点只能是一个数据节点，此时总容量的数量级就是 10 这个级别</li><li>整个B+Tree如果有两层：意味着根节点是目录节点，叶子节点是数据节点 <ul><li>目录节点容量：1024条记录，意味着目录节点下可以有1024个子节点</li><li>每一个子节点存放数据的容量：16</li><li>总计：1024×16≈1000×10=10000</li></ul></li><li>整个B+Tree如果有三层：意味着根节点是目录节点，中间一层还是目录节点，叶子节点是数据节点 <ul><li>根节点：容量是1024</li><li>第二层有1024个节点</li><li>第二层中的节点，每一个又可以存放1024个子节点</li><li>叶子节点每一个可以存放16条数据记录</li><li>总计：1024×1024×16约等于1000×1000×10=10000000</li></ul></li><li>规律：按照我们目前的设定，整个树形结构每增加一层，数据的总容量就乘以 1000</li></ul><br><p>MySQL 数据库表实际存储能力：</p><ul><li>单表存储数据的极限是大约1000万条数据（此时很可能执行查询语句的时间需要以分钟为单位计算）</li><li>单表数据量达到300万，趋势还是不断增加，那么就该考虑拆分表了</li></ul><br>',73),h=[o];function u(_,m){return e(),i("div",null,h)}const k=a(p,[["render",u],["__file","MySQL03-索引-主键索引.html.vue"]]);export{k as default};
