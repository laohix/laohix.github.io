import{_ as e,o as r,c as a,e as o}from"./app-8007fa1b.js";const t={},d=o('<h1 id="juc" tabindex="-1"><a class="header-anchor" href="#juc" aria-hidden="true">#</a> JUC</h1><h1 id="什么是线程池-线程池有哪些" tabindex="-1"><a class="header-anchor" href="#什么是线程池-线程池有哪些" aria-hidden="true">#</a> 什么是线程池，线程池有哪些？</h1><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率</p><p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。</p><p>ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</p><p>ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);</p><p>ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);</p><p>ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</p><p>然后调用他们的 execute 方法即可。</p><h2 id="_1-newcachedthreadpool" tabindex="-1"><a class="header-anchor" href="#_1-newcachedthreadpool" aria-hidden="true">#</a> （<strong>1</strong>）<strong>newCachedThreadPool</strong></h2><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p><p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p><p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p><p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p><h2 id="_2-newfixedthreadpool" tabindex="-1"><a class="header-anchor" href="#_2-newfixedthreadpool" aria-hidden="true">#</a> （<strong>2</strong>）newFixedThreadPool</h2><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><h2 id="_3-newsinglethreadexecutor" tabindex="-1"><a class="header-anchor" href="#_3-newsinglethreadexecutor" aria-hidden="true">#</a> （<strong>3</strong>）<strong>newSingleThreadExecutor</strong></h2><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><h2 id="_4-newschedulethreadpool" tabindex="-1"><a class="header-anchor" href="#_4-newschedulethreadpool" aria-hidden="true">#</a> （<strong>4</strong>）<strong>newScheduleThreadPool</strong></h2><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3秒执行。</p><p>这4种线程池底层 全部是ThreadPoolExecutor对象的实现，阿里规范手册中规定线程池采用ThreadPoolExecutor自定义的，实际开发也是。</p><h2 id="threadpoolexecutor对象有哪些参数-都有什么作用-怎么设定核心线程数和最大线程数-拒绝策略有哪些-重点" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor对象有哪些参数-都有什么作用-怎么设定核心线程数和最大线程数-拒绝策略有哪些-重点" aria-hidden="true">#</a> ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点]</h2><p>参数与作用：共7个参数</p><h2 id="corepoolsize" tabindex="-1"><a class="header-anchor" href="#corepoolsize" aria-hidden="true">#</a> corePoolSize</h2><p>核心线程数，在ThreadPoolExecutor中有一个与它相关的配置：allowCoreThreadTimeOut（默认为false），当allowCoreThreadTimeOut为false时，核心线程会一直存活，哪怕是一直空闲着。而当allowCoreThreadTimeOut为true时核心线程空闲时间超过keepAliveTime时会被回收。</p><h2 id="maximumpoolsize" tabindex="-1"><a class="header-anchor" href="#maximumpoolsize" aria-hidden="true">#</a> maximumPoolSize</h2><p>最大线程数，线程池能容纳的最大线程数，当线程池中的线程达到最大时，此时添加任务将会采用拒绝策略，默认的拒绝策略是抛出一个运行时错误（RejectedExecutionException）。值得一提的是，当初始化时用的工作队列为LinkedBlockingDeque时，这个值将无效。</p><h2 id="keepalivetime" tabindex="-1"><a class="header-anchor" href="#keepalivetime" aria-hidden="true">#</a> keepAliveTime</h2><p>存活时间，当非核心空闲超过这个时间将被回收，同时空闲核心线程是否回收受allowCoreThreadTimeOut影响。</p><h2 id="unit" tabindex="-1"><a class="header-anchor" href="#unit" aria-hidden="true">#</a> unit</h2><p>keepAliveTime的单位。</p><h2 id="workqueue" tabindex="-1"><a class="header-anchor" href="#workqueue" aria-hidden="true">#</a> workQueue</h2><p>任务队列，常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。</p><h2 id="threadfactory" tabindex="-1"><a class="header-anchor" href="#threadfactory" aria-hidden="true">#</a> threadFactory</h2><p>线程工厂，ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。</p><h2 id="rejectedexecutionhandler" tabindex="-1"><a class="header-anchor" href="#rejectedexecutionhandler" aria-hidden="true">#</a> RejectedExecutionHandler</h2><p>也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。</p><p>默认是抛出一个运行时异常。</p><h2 id="线程池大小设置" tabindex="-1"><a class="header-anchor" href="#线程池大小设置" aria-hidden="true">#</a> <strong>线程池大小设置：</strong></h2><ol><li>需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型</li><li>每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系</li></ol><p>如果是 CPU 密集型，主要是执行计算任务，响应时间很快，cpu 一直在运行，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定，CPU 核心数=最大同时执行线程数，加入 CPU 核心数为 4，那么服务器最多能同时执行 4 个线程。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 如果是 IO 密集型，主要是进行 IO 操作，执行 IO 操作的时间较长，这是 cpu 出于空闲状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。一般可以配置 cpu 核心数的 2 倍。</p><p>一个公式：线程池设定最佳线程数目 = （（线程池设定的线程等待时间+线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目</p><p>这个公式的线程 cpu 时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 loadrunner测试大量运行次数求出平均值）</p><h2 id="拒绝策略" tabindex="-1"><a class="header-anchor" href="#拒绝策略" aria-hidden="true">#</a> <strong>拒绝策略：</strong></h2><h3 id="_1、abortpolicy" tabindex="-1"><a class="header-anchor" href="#_1、abortpolicy" aria-hidden="true">#</a> 1、AbortPolicy</h3><p>直接抛出异常，默认策略；</p><h3 id="_2、callerrunspolicy" tabindex="-1"><a class="header-anchor" href="#_2、callerrunspolicy" aria-hidden="true">#</a> 2、CallerRunsPolicy</h3><p>用调用者所在的线程来执行任务；</p><h3 id="_3、discardoldestpolicy" tabindex="-1"><a class="header-anchor" href="#_3、discardoldestpolicy" aria-hidden="true">#</a> 3、DiscardOldestPolicy</h3><p>丢弃阻塞队列中靠最前的任务，并执行当前任务；</p><h3 id="_4、discardpolicy" tabindex="-1"><a class="header-anchor" href="#_4、discardpolicy" aria-hidden="true">#</a> 4、DiscardPolicy</h3><p>直接丢弃任务； 当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p><h1 id="常见线程安全的并发容器有哪些" tabindex="-1"><a class="header-anchor" href="#常见线程安全的并发容器有哪些" aria-hidden="true">#</a> 常见线程安全的并发容器有哪些？</h1><p>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap。</p><p>CopyOnWriteArrayList、CopyOnWriteArraySet采用写时复制实现线程安全</p><p>ConcurrentHashMap采用分段锁的方式实现线程安全</p><h1 id="atomic原子类了解多少-原理是什么" tabindex="-1"><a class="header-anchor" href="#atomic原子类了解多少-原理是什么" aria-hidden="true">#</a> Atomic原子类了解多少？原理是什么？</h1><p>Java 的原子类都存放在并发包 java.util.concurrent.atomic 下，如下图：</p><h2 id="基本类型" tabindex="-1"><a class="header-anchor" href="#基本类型" aria-hidden="true">#</a> <strong>基本类型</strong></h2><p>· 使用原子的方式更新基本类型</p><p>· AtomicInteger：整形原子类</p><p>· AtomicLong：长整型原子类</p><p>· AtomicBoolean：布尔型原子类</p><h2 id="数组类型" tabindex="-1"><a class="header-anchor" href="#数组类型" aria-hidden="true">#</a> <strong>数组类型</strong></h2><p>· 使用原子的方式更新数组里的某个元素</p><p>· AtomicIntegerArray：整形数组原子类</p><p>· AtomicLongArray：长整形数组原子类</p><p>· AtomicReferenceArray：引用类型数组原子类</p><h2 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型" aria-hidden="true">#</a> <strong>引用类型</strong></h2><p>· AtomicReference：引用类型原子类</p><p>· AtomicStampedReference：原子更新引用类型里的字段原子类</p><p>· AtomicMarkableReference ：原子更新带有标记位的引用类型</p><p>· 对象的属性修改类型</p><p>· AtomicIntegerFieldUpdater：原子更新整形字段的更新器</p><p>· AtomicLongFieldUpdater：原子更新长整形字段的更新器</p><p>· AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，以及解决使用 CAS 进行原子更新时可能出现的 ABA 问题</p><p>AtomicInteger 类利用 CAS (Compare and Swap) + volatile + native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理，是拿期望值和原本的值作比较，如果相同，则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是个本地方法，这个方法是用来拿“原值”的内存地址，返回值是 valueOffset；另外，value 是一个 volatile 变量，因此 JVM 总是可以保证任意时刻的任何线程总能拿到该变量的最新值。</p><h1 id="synchronized底层实现是什么-lock底层是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#synchronized底层实现是什么-lock底层是什么-有什么区别" aria-hidden="true">#</a> synchronized底层实现是什么？lock底层是什么？有什么区别？</h1><h2 id="synchronized原理" tabindex="-1"><a class="header-anchor" href="#synchronized原理" aria-hidden="true">#</a> <strong>Synchronized原理：</strong></h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p><p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><h2 id="lock原理" tabindex="-1"><a class="header-anchor" href="#lock原理" aria-hidden="true">#</a> <strong>Lock原理：</strong></h2><p>· Lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</p><p>· Lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</p><p>· Lock释放锁的过程：修改状态值，调整等待链表。</p><p>· Lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。</p><h2 id="lock与synchronized的区别" tabindex="-1"><a class="header-anchor" href="#lock与synchronized的区别" aria-hidden="true">#</a> <strong>Lock与synchronized的区别</strong></h2><ol><li>Lock的加锁和解锁都是由java代码配合native方法（调用操作系统的相关方法）实现的，而synchronize的加锁和解锁的过程是由JVM管理的</li><li>当一个线程使用synchronize获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。而Lock则提供超时锁和可中断等更加灵活的方式，在未能获取锁的 条件下提供一种退出的机制。</li><li>一个锁内部可以有多个Condition实例，即有多路条件队列，而synchronize只有一路条件队列；同样Condition也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以 及设置等待时限等方式退出条件队列。</li><li>synchronize对线程的同步仅提供独占模式，而Lock即可以提供独占模式，也可以提供共享模式</li></ol><table><thead><tr><th>synchronized</th><th>Lock</th></tr></thead><tbody><tr><td>关键字</td><td>接口/类</td></tr><tr><td>自动加锁和释放锁</td><td>需要手动调用unlock() 方法释放锁</td></tr><tr><td>JVM层面的锁</td><td>API层面的锁</td></tr><tr><td>非公平锁</td><td>可以选择公平或者非公平锁</td></tr><tr><td>锁是一个对象，并且锁的信息保存在了对象中</td><td>代码中通过int类型的state标识</td></tr><tr><td>有一个锁升级的过程</td><td>无</td></tr></tbody></table>',90),i=[d];function n(h,c){return r(),a("div",null,i)}const l=e(t,[["render",n],["__file","JUC.html.vue"]]);export{l as default};
