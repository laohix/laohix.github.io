import{_ as a}from"./img006-3d15a5c0.js";import{_ as e,o as t,c as i,e as r}from"./app-8007fa1b.js";const n={},d=r(`<h1 id="一、本地接口-native-interface" tabindex="-1"><a class="header-anchor" href="#一、本地接口-native-interface" aria-hidden="true">#</a> 一、本地接口 Native Interface</h1><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。因为 Java 诞生的时候是 C/C++ 横行的时候，要想立足，必须有能力调用 C/C++。于是就在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是 Native Method Stack 中登记 native 方法，在Execution Engine 执行时加载 native libraies。</p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p><h1 id="二、本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#二、本地方法栈-native-method-stack" aria-hidden="true">#</a> 二、本地方法栈 Native Method Stack</h1><p>专门负责在本地方法运行时，提供栈空间，存放本地方法每一次执行时创建的栈帧。它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p>native 方法举例：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public static native void yield();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>栈：stack 堆：heap 如果抛开JVM内存结构，单独来看『栈』和『堆』其实没有区别，都是指：先进后出的数据结构。</p></blockquote><h1 id="三、程序计数器" tabindex="-1"><a class="header-anchor" href="#三、程序计数器" aria-hidden="true">#</a> 三、程序计数器</h1><p>也叫PC寄存器（<strong>P</strong>rogram <strong>C</strong>ounter Register）。用于保存程序执行过程中，下一条即将执行的指令的地址。也就是说能够保存程序当前已经执行到的位置。这个位置由执行引擎读取下一条指令，是一个非常小的内存空间，从内存空间使用优化这个角度来看：几乎可以忽略不记。</p><h1 id="四、直接内存" tabindex="-1"><a class="header-anchor" href="#四、直接内存" aria-hidden="true">#</a> 四、直接内存</h1><p><img src="`+a+'" alt=""></p><h2 id="_1、作用" tabindex="-1"><a class="header-anchor" href="#_1、作用" aria-hidden="true">#</a> 1、作用</h2><p>在特定场景提高性能。</p><h2 id="_2、应用场景" tabindex="-1"><a class="header-anchor" href="#_2、应用场景" aria-hidden="true">#</a> 2、应用场景</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。 配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。</p><h2 id="_3、直接内存和堆内存比较" tabindex="-1"><a class="header-anchor" href="#_3、直接内存和堆内存比较" aria-hidden="true">#</a> 3、直接内存和堆内存比较</h2><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。直接内存 I/O 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</p>',18),c=[d];function h(s,o){return t(),i("div",null,c)}const p=e(n,[["render",h],["__file","03-JVM-不重要部分.html.vue"]]);export{p as default};
