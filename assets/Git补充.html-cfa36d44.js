import{_ as e,o as a,c as r,e as i}from"./app-8007fa1b.js";const t="/assets/001-bff33652.png",d="/assets/002-7d73dfd3.png",h="/assets/003-bf4e2a5f.png",s="/assets/004-e79d71b8.png",c="/assets/012-98a0827a.png",o="/assets/006-696d5809.png",n="/assets/005-8f19eaf7.png",l="/assets/007-afb83180.png",p="/assets/008-5e37bdc2.png",g="/assets/009-5179362b.png",_="/assets/010-05e13116.png",m="/assets/011-50055847.png",b={},f=i('<h1 id="一、git的四个空间" tabindex="-1"><a class="header-anchor" href="#一、git的四个空间" aria-hidden="true">#</a> 一、Git的四个空间</h1><h2 id="_1-工作区" tabindex="-1"><a class="header-anchor" href="#_1-工作区" aria-hidden="true">#</a> 1. 工作区</h2><p>工作区其实就是代码的目录</p><p><img src="'+t+'" alt=""></p><h2 id="_2-版本库" tabindex="-1"><a class="header-anchor" href="#_2-版本库" aria-hidden="true">#</a> 2. 版本库</h2><p>版本库其实就是.git目录</p><p><img src="'+d+'" alt=""></p><h3 id="_2-1-暂存区-stage" tabindex="-1"><a class="header-anchor" href="#_2-1-暂存区-stage" aria-hidden="true">#</a> 2.1 暂存区( stage )</h3><p>index文件就是暂存区，暂存区中记录的是将要被commit的文件列表</p><h3 id="_2-2-本地仓库" tabindex="-1"><a class="header-anchor" href="#_2-2-本地仓库" aria-hidden="true">#</a> 2.2 本地仓库</h3><h3 id="_2-2-1-refs目录" tabindex="-1"><a class="header-anchor" href="#_2-2-1-refs目录" aria-hidden="true">#</a> 2.2.1 refs目录</h3><p><img src="'+h+'" alt=""></p><p>refs目录中的heads目录包含了本地每一个分支执行的commit版本</p><p>remotes目录包含了远程每一个分支执行的commit版本</p><h3 id="_2-2-2-head文件" tabindex="-1"><a class="header-anchor" href="#_2-2-2-head文件" aria-hidden="true">#</a> 2.2.2 HEAD文件</h3><p><img src="'+s+`" alt=""></p><p>记录当前是在哪个分支</p><h3 id="_2-2-3-objects目录" tabindex="-1"><a class="header-anchor" href="#_2-2-3-objects目录" aria-hidden="true">#</a> 2.2.3 objects目录</h3><p>类似Git的数据库(键值对数据库)，以键值对方式保存Git对象，key就是内容的SHA1值</p><p>查询对象的命令:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> cat-file 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2-2-3-1-数据对象" tabindex="-1"><a class="header-anchor" href="#_2-2-3-1-数据对象" aria-hidden="true">#</a> 2.2.3.1 数据对象</h4><p>数据对象就是文件内容</p><h4 id="_2-2-3-2-树对象" tabindex="-1"><a class="header-anchor" href="#_2-2-3-2-树对象" aria-hidden="true">#</a> 2.2.3.2 树对象</h4><p>用于保存文件路径</p><p><img src="`+c+'" alt=""></p><h4 id="_2-2-3-3-提交对象" tabindex="-1"><a class="header-anchor" href="#_2-2-3-3-提交对象" aria-hidden="true">#</a> 2.2.3.3 提交对象</h4><p>用于保存commit信息</p><h2 id="_3-远程仓库" tabindex="-1"><a class="header-anchor" href="#_3-远程仓库" aria-hidden="true">#</a> 3. 远程仓库</h2><h1 id="二、git的分支" tabindex="-1"><a class="header-anchor" href="#二、git的分支" aria-hidden="true">#</a> 二、Git的分支</h1><h2 id="_1-分支操作命令" tabindex="-1"><a class="header-anchor" href="#_1-分支操作命令" aria-hidden="true">#</a> 1. 分支操作命令</h2><ol><li><code>git branch</code> 查看本地分支</li><li><code>git branch -r</code> 查看远程分支</li><li><code>git branch 分支名</code> 创建分支</li><li><code>git checkout 分支名</code> 检出分支</li><li><code>git branch -D 分支名</code> 删除本地分支</li></ol><h2 id="_2-merge合并分支" tabindex="-1"><a class="header-anchor" href="#_2-merge合并分支" aria-hidden="true">#</a> 2. merge合并分支</h2><ol><li><code>git merge 要合并过来的分支名</code> 将某个分支合并到当前分支</li><li><code>git log 分支名</code> 查看某个分支的提交记录</li></ol><h2 id="_3-rebase合并分支" tabindex="-1"><a class="header-anchor" href="#_3-rebase合并分支" aria-hidden="true">#</a> 3. rebase合并分支</h2><ol><li><code>git rebase 要合并过来的分支</code> 将某个分支合并到当前分支</li></ol><h2 id="_4-merge和rebase的区别" tabindex="-1"><a class="header-anchor" href="#_4-merge和rebase的区别" aria-hidden="true">#</a> 4. merge和rebase的区别</h2><h3 id="_4-1-图解" tabindex="-1"><a class="header-anchor" href="#_4-1-图解" aria-hidden="true">#</a> 4.1 图解</h3><h4 id="_4-1-1-使用merge" tabindex="-1"><a class="header-anchor" href="#_4-1-1-使用merge" aria-hidden="true">#</a> 4.1.1 使用merge</h4><p><img src="'+o+'" alt=""></p><h4 id="_4-1-2-使用rebase" tabindex="-1"><a class="header-anchor" href="#_4-1-2-使用rebase" aria-hidden="true">#</a> 4.1.2 使用rebase</h4><p><img src="'+n+'" alt=""></p><h3 id="_4-2-文字描述" tabindex="-1"><a class="header-anchor" href="#_4-2-文字描述" aria-hidden="true">#</a> 4.2 文字描述</h3><h4 id="_4-2-1-merge" tabindex="-1"><a class="header-anchor" href="#_4-2-1-merge" aria-hidden="true">#</a> 4.2.1 merge</h4><p>找到两个分支的祖先commit，合并的时候对比两个分支最新的commit，从而确定是否有冲突，会产生一条新的提交记录</p><p><img src="'+l+'" alt=""></p><h4 id="_4-2-2-rebase" tabindex="-1"><a class="header-anchor" href="#_4-2-2-rebase" aria-hidden="true">#</a> 4.2.2 rebase</h4><p>将当前分支从祖先的commit后的所有commit先撤销，放到一个缓存中，然后将需要rebase过来的那个分支变成当前分支的基，然后再从缓存中取出当前分支的commit，加到基的后面，不会产生一条新的提交记录</p><p><img src="'+p+'" alt=""></p><p>但是此时由于缓存中的commit有多个，rebase之后如果有冲突，可能需要解决多次冲突; 并且rebase之后，可能会导致 <code>git push 远程别名 分支名</code>失效，因为rebase之后，本地仓库的分支相较于远程仓库而言已经变基了，所以无法直接push， 所以确保没有问题的情况下必须使用 <code>--force</code> 参数才能提交；</p><h3 id="_4-3-优缺点" tabindex="-1"><a class="header-anchor" href="#_4-3-优缺点" aria-hidden="true">#</a> 4.3 优缺点</h3><h4 id="_4-3-1-merge" tabindex="-1"><a class="header-anchor" href="#_4-3-1-merge" aria-hidden="true">#</a> 4.3.1 merge</h4><h5 id="_4-3-1-1-优点" tabindex="-1"><a class="header-anchor" href="#_4-3-1-1-优点" aria-hidden="true">#</a> 4.3.1.1 优点</h5><ol><li>详细记录各个分支合并的情况:由谁合并的、什么时候合并的等等</li><li>合并时如果有冲突，只需要解决一次</li></ol><h5 id="_4-3-1-2-缺点" tabindex="-1"><a class="header-anchor" href="#_4-3-1-2-缺点" aria-hidden="true">#</a> 4.3.1.2 缺点</h5><ol><li>合并后分支图谱很乱</li><li>每次合并都会产生一条提交记录</li></ol><h4 id="_4-3-2-rebase" tabindex="-1"><a class="header-anchor" href="#_4-3-2-rebase" aria-hidden="true">#</a> 4.3.2 rebase</h4><h5 id="_4-3-2-1-优点" tabindex="-1"><a class="header-anchor" href="#_4-3-2-1-优点" aria-hidden="true">#</a> 4.3.2.1 优点</h5><ol><li>合并后分支图谱是一条线</li><li>每次合并不会产生一条提交记录</li></ol><h5 id="_4-3-2-2-缺点" tabindex="-1"><a class="header-anchor" href="#_4-3-2-2-缺点" aria-hidden="true">#</a> 4.3.2.2 缺点</h5><ol><li>合并后如果有冲突可能要解决多次冲突</li><li>无法详细记录合并情况</li></ol><h2 id="_5-具体怎么选择使用merge和rebase" tabindex="-1"><a class="header-anchor" href="#_5-具体怎么选择使用merge和rebase" aria-hidden="true">#</a> 5. 具体怎么选择使用merge和rebase</h2><ol><li>上游分支合并下游分支使用merge</li><li>下游分支合并更新上游分支代码使用rebase</li><li>更新当前分支代码最好是使用<code>git pull 远程别名 分支名 --rebase </code>,这样可以避免多出一条merge远程的日志</li></ol><h2 id="_6-分支管理规范" tabindex="-1"><a class="header-anchor" href="#_6-分支管理规范" aria-hidden="true">#</a> 6. 分支管理规范</h2><h3 id="_6-1-分支介绍" tabindex="-1"><a class="header-anchor" href="#_6-1-分支介绍" aria-hidden="true">#</a> 6.1 分支介绍</h3><ul><li><strong>Master :</strong> 主干分支, 是一个归档分支, 保留最新的一个稳定版本代码</li><li><strong>PRO</strong> : Production 生产环境分支, 用于测试完毕后发布生产环境</li><li><strong>FAT</strong> : Feature Acceptance Test功能验收测试环境，用于软件测试者测试使用</li><li><strong>DEV</strong> : Development 开发环境分支, 用于前后端联调测试, 以及代码自测发布使用</li><li><strong>Iteration</strong> : Iteration 敏捷迭代分支, 每个迭代开始时从Master检出的分支, 用于维护一个迭代周期的开发代码维护整合</li><li><strong>Features</strong> : 功能特性分支, 每个迭代多个Story对应的多个分支, 以一个可独立发布的功能为单位从Iteration分支检出</li></ul><p>Master、PRO、FAT、DEV为常驻分支, 不与迭代相关联. 且Master与PRO同为 Protected 受保护分支, 仅SM(Scrum Master)具有合并权限, FAT分支则是仅QA(测试负责人)具有合并权限, 当有新功能需要提测时, 则将Itetation分支合并到FAT并发布测试环境. 而Iteration与Features分支则为迭代相关分支, 生命周期与迭代保持一致, 在每个迭代开始的时候重新创建, 然后迭代结束后也同时删除销毁。</p><h3 id="_6-2-git分支与敏捷迭代时序图" tabindex="-1"><a class="header-anchor" href="#_6-2-git分支与敏捷迭代时序图" aria-hidden="true">#</a> 6.2 GIT分支与敏捷迭代时序图</h3><p><img src="'+g+'" alt=""></p><h3 id="_6-3-敏捷迭代分支管理流程图" tabindex="-1"><a class="header-anchor" href="#_6-3-敏捷迭代分支管理流程图" aria-hidden="true">#</a> 6.3 敏捷迭代分支管理流程图</h3><p><img src="'+_+'" alt=""></p><h1 id="三、git版本回退" tabindex="-1"><a class="header-anchor" href="#三、git版本回退" aria-hidden="true">#</a> 三、Git版本回退</h1><h2 id="_1-提交日志" tabindex="-1"><a class="header-anchor" href="#_1-提交日志" aria-hidden="true">#</a> 1. 提交日志</h2><ol><li><code>git log 分支名</code>显示详细提交日志，但是只会列出有效日志不包含回退的日志</li><li><code>git log --oneline 分支名</code>，一条日志一行</li><li><code>git reflog</code> 会显示所有的日志，包含回滚日志</li></ol><h2 id="_2-本地仓库回退" tabindex="-1"><a class="header-anchor" href="#_2-本地仓库回退" aria-hidden="true">#</a> 2. 本地仓库回退</h2><h3 id="_2-1-reset" tabindex="-1"><a class="header-anchor" href="#_2-1-reset" aria-hidden="true">#</a> 2.1 reset</h3><p>回退命令<code>git reset --参数 版本号</code></p><h4 id="_2-1-1-hard参数" tabindex="-1"><a class="header-anchor" href="#_2-1-1-hard参数" aria-hidden="true">#</a> 2.1.1 hard参数</h4><p>回退工作区、暂存区、本地仓库中的内容</p><h4 id="_2-1-2-mixed参数" tabindex="-1"><a class="header-anchor" href="#_2-1-2-mixed参数" aria-hidden="true">#</a> 2.1.2 mixed参数</h4><p>回退暂存区和本地仓库中的内容</p><h4 id="_2-1-3-soft参数" tabindex="-1"><a class="header-anchor" href="#_2-1-3-soft参数" aria-hidden="true">#</a> 2.1.3 soft参数</h4><p>回退本地仓库中的内容</p><h3 id="_2-2-revert" tabindex="-1"><a class="header-anchor" href="#_2-2-revert" aria-hidden="true">#</a> 2.2 revert</h3><p><code>revert 回退版本</code> 相当于将某个版本从提交中去掉，然后就可以重做该版本的内容(重新提交一次)</p><h3 id="_2-3-reset和revert的区别" tabindex="-1"><a class="header-anchor" href="#_2-3-reset和revert的区别" aria-hidden="true">#</a> 2.3 reset和revert的区别</h3><h2 id="_4-远程仓库回退" tabindex="-1"><a class="header-anchor" href="#_4-远程仓库回退" aria-hidden="true">#</a> 4. 远程仓库回退</h2><p><code>git push --force</code> 强制将本地回退后的代码推送到远程仓库</p><h1 id="四、git-commit-message-填写规范" tabindex="-1"><a class="header-anchor" href="#四、git-commit-message-填写规范" aria-hidden="true">#</a> 四、GIT commit message 填写规范</h1><p>现在市面上比较流行的方案是约定式提交规范（Conventional Commits），它受到了Angular提交准则的启发，并在很大程度上以其为依据。约定式提交规范是一种基于提交消息的轻量级约定。 它提供了一组用于创建清晰的提交历史的简单规则；这使得编写基于规范的自动化工具变得更容易。这个约定与SemVer相吻合，在提交信息中描述新特性、bug 修复和破坏性变更。它的 message 格式如下:</p><p>&lt;类型&gt;[可选的作用域]: &lt;描述&gt;</p><p>[可选的正文]</p><p>[可选的脚注]</p><p><strong>1. type</strong></p><p>type为必填项，用于指定commit的类型，约定了feat、fix两个主要type，以及docs、style、build、refactor、revert五个特殊type，其余type暂不使用。</p><p># 主要type feat: 增加新功能 fix: 修复bug # 特殊type docs: 只改动了文档相关的内容 style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message # 暂不使用type test: 添加测试或者修改现有测试 perf: 提高性能的改动 ci: 与CI（持续集成服务）有关的改动 chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动</p><p>当一次改动包括主要type与特殊type时，统一采用主要type。</p><p><strong>2. scope</strong></p><p>scope也为必填项，用于描述改动的范围，格式为项目名/模块名，例如： node-pc/common rrd-h5/activity，而we-sdk不需指定模块名。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。</p><p><strong>3. body</strong></p><p>body填写详细描述，主要描述改动之前的情况及修改动机，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。</p><p><strong>4. break changes</strong></p><p>break changes指明是否产生了破坏性修改，涉及break changes的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。</p><p><strong>5. affect issues</strong></p><p>affect issues指明是否影响了某个问题。例如我们使用jira时，我们在commit message中可以填写其影响的JIRA_ID，若要开启该功能需要先打通jira与gitlab</p><p><img src="'+m+'" alt=""></p><h1 id="五、其它" tabindex="-1"><a class="header-anchor" href="#五、其它" aria-hidden="true">#</a> 五、其它</h1><ol><li><code>git cherry-pick 需要复制过来的commit的id</code> 将其它的分支的某个commit复制到当前分支: 当两个分支都还未开发完，不能进行合并，但是刚好此时A分支需要B分支某次commit的内容，这个时候就可以用该命令</li><li><code>git stash </code> 贮藏当前的changes:当正在开发一个需求，还未开发完，此时我们需要切换去另一个分支开发，如果我们直接切换分支拉代码的话，那么我们当前未提交的内容就丢失了。而且我们又不想因为要切换分支，而先将当前代码进行commit导致产生一次不必要的commit，此时我们可以使用该命令将我们做的changes贮藏起来，等另一个需求做完了，我们再切换回这个分支的时候再使用<code>git stash pop</code>命令弹出最后一次贮藏的change继续开发</li><li><code>git fetch</code>和<code>git pull </code>的区别: <ol><li><code>git fetch</code> 是拉取远程仓库的代码到本地仓库，但是不会与本地的分支进行合并</li><li><code>git pull</code>相当于<code>fetch + merge</code> 是拉取远程仓库代码到本地仓库，并且进行自动合并</li></ol></li></ol>',108),u=[f];function x(v,y){return a(),r("div",null,u)}const A=e(b,[["render",x],["__file","Git补充.html.vue"]]);export{A as default};
