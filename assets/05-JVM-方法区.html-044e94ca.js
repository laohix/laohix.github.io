import{_ as i,o as l,c as a,e}from"./app-8007fa1b.js";const t="/assets/img008-1ff69eb8.png",r="/assets/img009-f0d686f2.png",s="/assets/img010-0ac5df6d.png",o={},c=e('<h1 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念" aria-hidden="true">#</a> 一、概念</h1><ul><li>标准层面：方法区（Method Area）</li><li>具体实现层面： <ul><li>≤1.6 永久代（PermGen）</li><li>=1.7 永久代仍然存在，但是已经开始提出：去永久代</li><li>≥1.8元空间（Meta Space）</li></ul></li></ul><h1 id="二、概念的辨析" tabindex="-1"><a class="header-anchor" href="#二、概念的辨析" aria-hidden="true">#</a> 二、概念的辨析</h1><ul><li>从方法区角度来说 <ul><li>方法区的具体实现：JDK 版本 ≤ 1.7 时，使用永久代作为方法区。</li><li>方法区的具体实现：JDK 版本 ≥ 1.8 时，使用元空间作为方法区。</li></ul></li><li>从堆空间角度来说 <ul><li>新生代：从标准和实现层面都确定属于堆</li><li>老年代：从标准和实现层面都确定属于堆</li><li>永久代 <ul><li>名义上属于堆</li><li>实现上不属于堆，它另外有一个名字叫：非堆（Non-heap）</li></ul></li></ul></li></ul><br><p><img src="'+t+'" alt=""></p><h1 id="三、方法区存放内容" tabindex="-1"><a class="header-anchor" href="#三、方法区存放内容" aria-hidden="true">#</a> 三、方法区存放内容</h1><ul><li>类信息：类中定义的构造器、接口定义</li><li>静态变量（类变量）：private static String some;</li><li>常量：public static final String SYS_MESSAGE=&quot;hello&quot;;</li><li>运行时常量池：&quot;a&quot;、&quot;abc&quot;、&quot;hello&quot;</li><li>类中方法的代码</li></ul><br><h1 id="四、类加载机制和方法区的关系" tabindex="-1"><a class="header-anchor" href="#四、类加载机制和方法区的关系" aria-hidden="true">#</a> 四、类加载机制和方法区的关系</h1><ul><li>类加载到JVM内存后，类的静态存储结构转化为方法区的运行时数据结构</li><li>类加载后，会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口</li><li>类的字节码文件中有存放静态数据的常量池，类加载到内存后，字节码文件中的常量池会映射到方法区中的常量池</li></ul><br><p><img src="'+r+'" alt=""></p><h1 id="五、代码示例" tabindex="-1"><a class="header-anchor" href="#五、代码示例" aria-hidden="true">#</a> 五、代码示例</h1><p><img src="'+s+'" alt=""></p><blockquote><p>说明：即使多个线程执行的是同一个方法，也并不是都拥挤到方法区去执行方法代码。而是取得一份方法中代码指令的拷贝。</p></blockquote>',16),n=[c];function h(u,d){return l(),a("div",null,n)}const p=i(o,[["render",h],["__file","05-JVM-方法区.html.vue"]]);export{p as default};
