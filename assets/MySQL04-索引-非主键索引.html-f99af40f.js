import{_ as t,o as a,c as e,e as d}from"./app-8007fa1b.js";const s="/assets/img019-6e23c8ea.png",r="/assets/img020-bdbccfd7.png",n="/assets/img021-17817d02.png",i="/assets/image-20230618094239826-8bb4e070.png",p="/assets/image-20230618094404240-1bf51651.png",l="/assets/image-20230618094844386-cf6b81b0.png",h="/assets/image-20230618095053363-c0fef063.png",o="/assets/image-20230618095515772-18a2aed7.png",c="/assets/image-20230618095453756-d119504a.png",m="/assets/image-20230618100719352-f95c0219.png",_="/assets/img016-1c86a03d.png",g="/assets/img017-8ec35e3c.png",u="/assets/img018-f38624ee.png",b={},y=d('<h1 id="一、聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#一、聚簇索引和非聚簇索引" aria-hidden="true">#</a> 一、聚簇索引和非聚簇索引</h1><h2 id="_1、聚簇索引" tabindex="-1"><a class="header-anchor" href="#_1、聚簇索引" aria-hidden="true">#</a> 1、聚簇索引</h2><ul><li>索引和原始数据在一起，从硬盘存储文件的角度来说，存放在同一个文件中，就是聚簇索引</li><li>主键索引本身就是聚簇索引，同时也是数据库表本身</li><li>所以下面三个概念指的是同一个东西： <ul><li>主键索引：侧重点在于强调索引是基于主键字段创建的</li><li>聚簇索引：侧重点在于强调索引和数据在一起</li><li>数据库表本身：测试重点在于面向应用</li></ul></li></ul><p>注意：实际上上面这个说法需要有一个前提条件，那就是在InnoDB引擎中才成立；MyISAM引擎即使是主键索引页是非聚簇的</p><br><h2 id="_2、非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_2、非聚簇索引" aria-hidden="true">#</a> 2、非聚簇索引</h2><p>索引结构和原始数据不在一起，在数据库表文件之外的另一个文件中保存索引结构，这就是非聚簇索引<br> 以下三个概念也是一样的：</p><ul><li>非主键索引：侧重于强调索引是根据非主键字段创建的</li><li>二级索引：把主键索引视为一级索引，非主键索引就是二级的</li><li>非聚簇索引：侧重于强调索引结构和原始数据不在一起</li></ul><br><h2 id="_3、非主键索引的构成" tabindex="-1"><a class="header-anchor" href="#_3、非主键索引的构成" aria-hidden="true">#</a> 3、非主键索引的构成</h2><p><img src="'+s+`" alt="img.png"></p><br><ul><li>用于创建索引的字段，总体上需要排序</li><li>在排序过程中，遇到相同的字段值，就会连在一起</li></ul><table><thead><tr><th>主键值</th><th>索引字段值</th></tr></thead><tbody><tr><td>38</td><td>22</td></tr><tr><td>36</td><td>23</td></tr><tr><td>15</td><td>23</td></tr><tr><td>66</td><td>23</td></tr><tr><td>7</td><td>34</td></tr></tbody></table><ul><li>字符串也可以排序 <ul><li>根据字母顺序排序</li><li>底层字符编码排序</li></ul></li></ul><br><h2 id="_4、多个字段的情况" tabindex="-1"><a class="header-anchor" href="#_4、多个字段的情况" aria-hidden="true">#</a> 4、多个字段的情况</h2><h3 id="_1多字段排序问题" tabindex="-1"><a class="header-anchor" href="#_1多字段排序问题" aria-hidden="true">#</a> ①多字段排序问题</h3><p>首先要解决一个问题：多个字段如何排序？<br> 回想：SQL 中order by子句是不是可以包含多个字段？<br> 规则：先根据第一个字段排序</p><ul><li>如果第一个字段中没有重复值，那么就单纯根据第一个字段排序，后面字段就不看了</li><li>如果第一个字段中有重复值，那么在重复值范围内，再根据第二个字段排序</li><li>如果第二个字段中也有重复值，那么在重复值范围内，再根据第三个字段排序</li></ul><br><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">order</span> <span class="token keyword">by</span> age<span class="token punctuation">,</span>salary<span class="token punctuation">,</span>grade
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br><table><thead><tr><th>age</th><th>salary</th><th>grade</th></tr></thead><tbody><tr><td>21</td><td>6600</td><td>5</td></tr><tr><td>22</td><td>5533</td><td>4</td></tr><tr><td>23</td><td>2211</td><td>3</td></tr><tr><td>23</td><td>1000</td><td>8</td></tr><tr><td>23</td><td>1500</td><td>18</td></tr><tr><td>23</td><td>1500</td><td>19</td></tr><tr><td>23</td><td>1500</td><td>20</td></tr><tr><td>23</td><td>1800</td><td>4</td></tr></tbody></table><br><h3 id="_2构成" tabindex="-1"><a class="header-anchor" href="#_2构成" aria-hidden="true">#</a> ②构成</h3><p><img src="`+r+`" alt="img.png"></p><br><h3 id="_3索引值" tabindex="-1"><a class="header-anchor" href="#_3索引值" aria-hidden="true">#</a> ③索引值</h3><p>用哪个字段创建了索引，这个字段的值就是索引值</p><ul><li>主键索引：主键值就是索引值</li><li>非主键索引：创建索引的字段的值，就是索引值</li><li>单列索引：索引值就是一个单个值</li><li>多列索引：索引值就是创建索引时指定的多个字段的值</li></ul><br><h1 id="二、回表" tabindex="-1"><a class="header-anchor" href="#二、回表" aria-hidden="true">#</a> 二、回表</h1><h2 id="_1、非主键索引的查询过程" tabindex="-1"><a class="header-anchor" href="#_1、非主键索引的查询过程" aria-hidden="true">#</a> 1、非主键索引的查询过程</h2><p>假设我们有数据库表如下：</p><table><thead><tr><th>emp_id</th><th>emp_name</th><th>emp_age</th><th>emp_subject</th><th>emp_salary</th></tr></thead><tbody><tr><td>1</td><td>tom1</td><td>21</td><td>Java</td><td>1000</td></tr><tr><td>2</td><td>tom2</td><td>22</td><td>Java</td><td>2000</td></tr><tr><td>3</td><td>tom3</td><td>23</td><td>Java</td><td>3000</td></tr><tr><td>4</td><td>tom4</td><td>24</td><td>Java</td><td>4000</td></tr><tr><td>5</td><td>tom5</td><td>25</td><td>Java</td><td>5000</td></tr><tr><td>6</td><td>tom6</td><td>26</td><td>Java</td><td>6000</td></tr><tr><td>7</td><td>tom7</td><td>27</td><td>Java</td><td>7000</td></tr></tbody></table><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 创建索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_emp_age <span class="token keyword">on</span> t_emp<span class="token punctuation">(</span>emp_age<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment"># 查询语句</span>
<span class="token keyword">select</span> emp_id<span class="token punctuation">,</span>emp_name<span class="token punctuation">,</span>emp_age<span class="token punctuation">,</span>emp_subject<span class="token punctuation">,</span>emp_salary <span class="token keyword">from</span> t_emp <span class="token keyword">where</span> emp_age<span class="token operator">=</span><span class="token number">24</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行回表操作： <br></p><p><img src="`+n+`" alt="img.png"></p><br><h2 id="_2、不需要回表的情况" tabindex="-1"><a class="header-anchor" href="#_2、不需要回表的情况" aria-hidden="true">#</a> 2、不需要回表的情况</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 查询之后，想要打印的字段在二级索引结构中全部都能找到，此时就不需要再回到主键索引中查询了</span>
<span class="token keyword">select</span> emp_id<span class="token punctuation">,</span> emp_name<span class="token punctuation">,</span> emp_age <span class="token keyword">from</span> emp_age<span class="token operator">=</span><span class="token number">24</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><br><p>覆盖索引：创建索引时用到的字段，已经能够把查询所需的数据都覆盖了，查询之后不需要回表<br> 所以覆盖索引并不是某一种索引类型，而只是描述一种效果，创建索引时如果能够尽量做到覆盖索引，减少回表操作，也能够提高性能</p><br><h1 id="三、与索引相关的数据结构" tabindex="-1"><a class="header-anchor" href="#三、与索引相关的数据结构" aria-hidden="true">#</a> 三、与索引相关的数据结构</h1><h2 id="_1、索引结构" tabindex="-1"><a class="header-anchor" href="#_1、索引结构" aria-hidden="true">#</a> 1、索引结构</h2><p>索引结构是指在数据库中用于<strong>组织和管理索引的数据结构</strong>。索引结构的设计和实现对于数据库的性能和效率具有重要影响。</p><p>常见的索引结构包括：</p><p>1、B树(B-tree): B树是一种平衡的<strong>多路搜索树</strong>，被广泛应用于数据库系统中。B树的特点是每个节点可以存储多个键值，并且保持有序。B树的高</p><p>度相对较低，可以快速定位到目标数据。</p><p>2、Hash索引（Hash Index）：Hash索引使用哈希函数将索引列的值映射为一个固定长度的哈希码，并将哈希码作为索引的键值。Hash索引适用于</p><p>等值查询，可以快速定位到目标数据。然而，Hash索引不支持范围查询和排序操作。</p><p>3、R树（R-tree）：R树是一种用于处理多维数据的索引结构，常用于地理信息系统（GIS）和空间数据库中。R树可以高效地支持范围查询和最近邻</p><p>查询。</p><p>4、Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</p><p>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指<strong>B+树</strong>（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、</p><p>唯一索引默认都是使用 B+tree 索引，统称为索引。</p><h2 id="_2、索引结构-树" tabindex="-1"><a class="header-anchor" href="#_2、索引结构-树" aria-hidden="true">#</a> 2、索引结构-树</h2><h3 id="_1二叉树" tabindex="-1"><a class="header-anchor" href="#_1二叉树" aria-hidden="true">#</a> ①二叉树</h3><h4 id="_1-二叉树" tabindex="-1"><a class="header-anchor" href="#_1-二叉树" aria-hidden="true">#</a> [1]二叉树</h4><p>树有很多种，<strong>每个节点最多只能有两个子节点</strong>的一种形式称为二叉树。二叉树的子节点分为左节点和右节点。</p><p><img src="`+i+'" alt="image-20230618094239826"></p><h4 id="_2-bst树" tabindex="-1"><a class="header-anchor" href="#_2-bst树" aria-hidden="true">#</a> [2]BST树</h4><h5 id="_1-bst的简介" tabindex="-1"><a class="header-anchor" href="#_1-bst的简介" aria-hidden="true">#</a> &lt;1&gt;BST的简介</h5><p>BST(Binary Sort(Search) Tree)：对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</p><p>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点。</p><p><img src="'+p+'" alt="image-20230618094404240"></p><p>BST的生成演示：https://www.cs.usfca.edu/~galles/visualization/BST.html</p><h5 id="_2-bst的问题" tabindex="-1"><a class="header-anchor" href="#_2-bst的问题" aria-hidden="true">#</a> &lt;2&gt;BST的问题</h5><p>二叉搜索树存在一个常见的问题：<strong>瘸腿问题</strong> ， 例如左子树全部为空，从形式上看，更像一个单链表，不能发挥BST的优势，影响了查询数据效率。</p><p><img src="'+l+'" alt="image-20230618094844386"></p><h4 id="_3-avl树" tabindex="-1"><a class="header-anchor" href="#_3-avl树" aria-hidden="true">#</a> [3]AVL树</h4><h5 id="_1-avl树简介" tabindex="-1"><a class="header-anchor" href="#_1-avl树简介" aria-hidden="true">#</a> &lt;1&gt;AVL树简介</h5><p>AVL树全称G.M. Adelson-Velsky和E.M. Landis，这是两个人的人名。</p><p>平衡二叉树也叫<strong>平衡二叉搜索树</strong>（Self-balancing binary search tree）又被称为AVL树， 可以保证较高的查询效率。</p><p>具有以下特点：</p><p>1、它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</p><p>2、并且左右两个子树都是一棵平衡二叉树。</p><p><img src="'+h+'" alt="image-20230618095053363"></p><p>AVL的生成演示：https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</p><h5 id="_2-avl树问题" tabindex="-1"><a class="header-anchor" href="#_2-avl树问题" aria-hidden="true">#</a> &lt;2&gt;AVL树问题</h5><p>众所周知，IO操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐节点加载（一个节点一次IO）。如果我</p><p>们利用二叉树作为索引结构，那么<strong>磁盘的IO次数和索引树的高度是相关</strong>的。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率</p><p>低下。</p><p><img src="'+o+'" alt="image-20230618095515772"></p><p>为了提高查询效率，就需要 减少磁盘IO数 。<strong>为了减少磁盘IO的次数，就需要尽量降低树的高度</strong>，需要把原来“瘦高”的树结构变的“矮胖”，树的每</p><p>层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三叉树：</p><p><img src="'+c+'" alt="image-20230618095453756"></p><p>上面的例子中，我们将二叉树变成了三叉树，降低了树的高度。如果能够在一个节点中存放更多的数据，我们还可以进一步减少节点的数量，从而进一</p><p>步降低树的高度。这就是多叉树。</p><h3 id="_2b-tree" tabindex="-1"><a class="header-anchor" href="#_2b-tree" aria-hidden="true">#</a> ②B-tree</h3><h4 id="_1-b-tree简介" tabindex="-1"><a class="header-anchor" href="#_1-b-tree简介" aria-hidden="true">#</a> [1]B-tree简介</h4><p>B-tree又叫<strong>多路平衡搜索树</strong>，一颗m叉的B-tree特性如下：</p><p>1、树中每个节点最多包含m个子节点。</p><p>2、除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。</p><p>3、若根节点不是叶子节点，则至少有两个孩子。</p><p>4、所有的叶子节点都在同一层。</p><p>5、每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1</p><p>如下所示：</p><p><img src="'+m+'" alt="image-20230618100719352"></p><h4 id="_2-数据搜索" tabindex="-1"><a class="header-anchor" href="#_2-数据搜索" aria-hidden="true">#</a> [2]数据搜索</h4><p>上图所表示的 B 树就是一棵 3 阶(叉)的 B 树。假设一个磁盘块可以存储一个节点的数据。我们可以看下磁盘块 2，里面的关键字为（8，12），它有 3</p><p>个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15)大于 12，三节点的子树的值大小仍然遵守 BST</p><p>二叉排序树的规则。</p><br><p>假设我们想要 查找的数据项是 9 ，那么步骤可以分为以下几步：</p><p>1、第一次磁盘IO：找到根节点磁盘块1，读入内存，执行二分查找，9 小于 17 ，得到指针 P1</p><p>2、第二次磁盘IO：按照指针P1找到磁盘块 2，读入内存，执行二分查找， 9 在 8 和 12 之间，得到指针 P2</p><p>3、第三次磁盘IO：按照指针P2找到磁盘块 6，读入内存，执行二分查找， 找到了数据项 9。</p><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果<strong>把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的</strong>。而读</p><p>取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素。 B树相比于平衡二叉树来说磁盘</p><p>I/O 操作要少 ，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p><h1 id="四、myisam索引结构" tabindex="-1"><a class="header-anchor" href="#四、myisam索引结构" aria-hidden="true">#</a> 四、MyISAM索引结构</h1><h2 id="_1、索引结构简介" tabindex="-1"><a class="header-anchor" href="#_1、索引结构简介" aria-hidden="true">#</a> 1、索引结构简介</h2><p>MyISAM引擎使用 B+Tree 作为索引结构，<strong>叶子节点的data域存放的是数据记录的地址</strong> 。</p><p>下图是MyISAM索引的原理图**（索引和数据分开存储，是非聚簇索引）**：</p><p><img src="'+_+'" alt="image"></p><br><p>如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示**（是非聚簇索引）**：</p><p><img src="'+g+'" alt="images"></p><br><h2 id="_2、myisam与innodb对比" tabindex="-1"><a class="header-anchor" href="#_2、myisam与innodb对比" aria-hidden="true">#</a> 2、MyISAM与InnoDB对比</h2><p>1、InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的：</p><ul><li>InnoDB的表在磁盘上存储在以下文件中： <strong>.ibd（表结构、索引和数据都存在一起,MySQL5.7表结构放在.frm中）</strong></li><li>MyISAM的表在磁盘上存储在以下文件中：<strong>.sdi（描述表结构，MySQL5.7是.frm）</strong>、<strong>.MYD（数据）</strong>，<strong>.MYI（索引）</strong></li></ul><p>2、InnoDB中主键索引是聚簇索引，叶子节点中存储完整的数据记录；其他索引是非聚簇索引，存储相应记录主键的值 。</p><p>3、InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以<strong>非空且唯一</strong>标识数据记录的列作为</p><p>主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。</p><p>4、MyISAM中无论是主键索引还是非主键索引都是非聚簇的，叶子节点记录的是数据的地址。</p><p>5、MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽</p><p>然说也不慢，但还是比不上直接用地址去访问。</p><p><img src="'+u+'" alt="images"></p><br>',135),f=[y];function v(k,x){return a(),e("div",null,f)}const I=t(b,[["render",v],["__file","MySQL04-索引-非主键索引.html.vue"]]);export{I as default};
